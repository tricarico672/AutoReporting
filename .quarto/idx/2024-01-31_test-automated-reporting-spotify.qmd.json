{"title":"Testing Automated Reporting","markdown":{"yaml":{"title":"Testing Automated Reporting","format":"html","editor":"visual","toc":true},"headingText":"Info about the dataset","containsRefs":false,"markdown":"\n\n\nData has been retrieved from [kaggle](https://www.kaggle.com/datasets/nelgiriyewithana/most-streamed-spotify-songs-2024/data).\n\nThe dataset description is reported below:\n\n-   **Track Name**: Name of the song.\n\n-   **Album Name**: Name of the album the song belongs to.\n\n-   **Artist**: Name of the artist(s) of the song.\n\n-   **Release Date**: Date when the song was released.\n\n-   **ISRC**: International Standard Recording Code for the song.\n\n-   **All Time Rank**: Ranking of the song based on its all-time popularity.\n\n-   **Track Score**: Score assigned to the track based on various factors.\n\n-   **Spotify Streams**: Total number of streams on Spotify.\n\n-   **Spotify Playlist Count**: Number of Spotify playlists the song is included in.\n\n-   **Spotify Playlist Reach**: Reach of the song across Spotify playlists.\n\n-   **Spotify Popularity**: Popularity score of the song on Spotify.\n\n-   **YouTube Views**: Total views of the song's official video on YouTube.\n\n-   **YouTube Likes**: Total likes on the song's official video on YouTube.\n\n-   **TikTok Posts**: Number of TikTok posts featuring the song.\n\n-   **TikTok Likes**: Total likes on TikTok posts featuring the song.\n\n-   **TikTok Views**: Total views on TikTok posts featuring the song.\n\n-   **YouTube Playlist Reach**: Reach of the song across YouTube playlists.\n\n-   **Apple Music Playlist Count**: Number of Apple Music playlists the song is included in.\n\n-   **AirPlay Spins**: Number of times the song has been played on radio stations.\n\n-   **SiriusXM Spins**: Number of times the song has been played on SiriusXM.\n\n-   **Deezer Playlist Count**: Number of Deezer playlists the song is included in.\n\n-   **Deezer Playlist Reach**: Reach of the song across Deezer playlists.\n\n-   **Amazon Playlist Count**: Number of Amazon Music playlists the song is included in.\n\n-   **Pandora Streams**: Total number of streams on Pandora.\n\n-   **Pandora Track Stations**: Number of Pandora stations featuring the song.\n\n-   **Soundcloud Streams**: Total number of streams on Soundcloud.\n\n-   **Shazam Counts**: Total number of times the song has been Shazamed.\n\n-   **TIDAL Popularity**: Popularity score of the song on TIDAL.\n\n-   **Explicit Track**: Indicates whether the song contains explicit content.\n\nThis is a test to check some of the functionality integrated to be integrated in a possible version of an automated reporting for spotify.\n\n## Creating the R and Python environments using `renv` and `venv`\n\nThe environment is created before loading any package and is stored in the file *build-env.R*.\n\n```{r, include=FALSE}\nlibrary(pacman)\np_load(tidyverse, arrow, duckdb, fs, DBI, glue, janitor, ggplot2, ggthemes, visdat, UpSetR, naniar)\n\n#options(scipen = 999)\noptions(scipen = 0)\n```\n\n## Using R to create a parquet file\n\n::: callout-note\nThis section should be executed only the first time to generate the parquet file, then we can just query that file using the opened connection to the database to extract and load only the necessary data in memory.\n:::\n\n```{r, warning=FALSE}\ndf <- read_csv(\"data/raw/2024_spotify-most-streamed.csv\")\n```\n\n```{r}\ndf_cleaned <- janitor::clean_names(df)\n```\n\n```{r}\ndir_out <- \"data/parquet/\"\n```\n\n```{r}\narrow::write_dataset(df_cleaned, dir_out, partitioning = \"spotify_popularity\")\n```\n\n### accessing and querying the parquet files using SQL and DuckDB\n\n```{r}\ndir_out <- \"data/parquet/\"\n```\n\n```{r}\nds <- open_dataset(dir_out, partitioning = \"spotify_popularity\")\n\ncon <- dbConnect(duckdb())\n\nduckdb_register_arrow(con, \"spotify_artists\", ds)\n\ndf_very_popular <- dbGetQuery(con,\n           \"SELECT *\n           FROM spotify_artists\n           WHERE spotify_popularity >= 70\")\n\ndf_not_popular <- dbGetQuery(con,\n           \"SELECT *\n           FROM spotify_artists\n           WHERE spotify_popularity < 70\")\n```\n\n```{r}\nduckdb_unregister(con, \"spotify_artists\")\ndbDisconnect(con)\n```\n\nThis ensures that after querying we disconnect and close the connection to the database.\n\n# Visualizing the data\n\nWe can first check the structure of the dataset to make sure that the type of every variable is consistent with what they are supposed to represent.\n\n```{r}\nstr(df_very_popular)\n```\n\nWe learn that the column `tidal_popularity` is full of empty values, so we should drop it from the dataset. Also, `release_date` is not properly initialized as a `date` object, so it would be useful to convert it into one.\n\n```{r}\ndf_cleaned_pop <- df_very_popular %>%\n  select(-tidal_popularity) %>%\n  mutate(release_date = mdy(release_date))\n```\n\nLet's say we want to try to understand the popularity of a track on spotify based on the number of likes it got. First let's visualize the most popular artists\n\n```{r}\nspotify_green <- \"#1DB954\"\n```\n\n```{r}\ndf_cleaned_pop %>%\n  group_by(artist) %>%\n  summarise(count = dplyr::n()) %>%\n  arrange(desc(count)) %>%\n  head(5) %>%\n  ggplot(aes(x = artist)) +\n    geom_col(aes(y = count), color = \"black\", fill = spotify_green) +\n    #stat_summary(aes(y = stat_identity(count))) +\n    labs(x = \"Artist\", y = \"Number of Popular Tracks (2024)\",\n         title = \"Top 5\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n```\n\nNow we might be interested in knowing from which year are the tracks contained in the dataset. We can observe the distribution using another barplot\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(release_year = year(release_date)) %>%\n  group_by(release_year) %>%\n  summarize(count = n()) %>%\n  ggplot(aes(x = release_year)) +\n    geom_col(aes(y = count), color = \"black\", fill = spotify_green) +\n    #stat_summary(aes(y = stat_identity(count))) +\n    labs(x = \"Year\", y = \"Number of Popular Tracks (2024)\",\n         title = \"Distribution of Release Year\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n  \n```\n\nMost of the popular songs are from 2023 and 2024, although there are a few outliers coming from the late 80s and early 90s. At this point one might be interested in understanding if the appearance of these songs on the chart is associated to the number of likes they received on social media platforms (e.g., TikTok & Instagram). Luckily, we also have this kind of data, so we can check how these two groups differ on the number of likes they received on social media.\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(period = ifelse(year(release_date) <= 2010, \"old\", \"recent\")) %>%\n  ggplot(aes(x = period, y = tik_tok_likes)) +\n  geom_boxplot(color = \"black\", fill = spotify_green) +\n  labs(x = \"Year\", y = \"Number of TikTok Likes (2024)\",\n         title = \"TikTok Likes by Period\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n```\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(period = ifelse(year(release_date) <= 2010, \"old\", \"recent\")) %>%\n  ggplot(aes(x = period, y = you_tube_likes)) +\n  geom_boxplot(color = \"black\", fill = spotify_green) +\n  labs(x = \"Year\", y = \"Number of YouTube Likes (2024)\",\n         title = \"YouTube Likes by Period\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n```\n\nHowever, there are many missing values for the TikTok category and so it is difficult to make a fair comparison. Also, YouTube has been around for much longer compared to TikTok so it makes sense that older songs gathered more likes throughout the years. Interestingly, among the old songs there is just one outlier in the YouTube category compared to the many in the TikTok group.\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(period = ifelse(year(release_date) <= 2010, \"old\", \"recent\")) %>%\n  select(tik_tok_likes, you_tube_likes) %>%\n  vis_miss()\n```\n\n::: {.content-visible when-format=\"html\"}\n```{python}\nimport pyarrow.dataset as ds\nimport pandas as pd\nimport plotly.express as px\nimport plotly.io as pio\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\ndf = ds.dataset(\"data/parquet\", format=\"parquet\").to_table().drop([\"artist\", \"album_name\", \"track\"]).to_pandas()\n\n#print(df)\n\n#df = pd.read_csv(\"~/Desktop/Projects/R_projects/test_reporting/data/raw/2024_spotify-most-streamed.csv\")\n\nfig = px.scatter(df, x=\"you_tube_views\", y=\"you_tube_likes\",\n                 marginal_y=\"violin\", marginal_x=\"violin\", \n                 trendline=\"ols\", template=\"simple_white\",\n                 title = \"YouTube Likes as a function of Views\",\n                 labels = {\"you_tube_views\":\"YT Views\", \"you_tube_likes\":\"YT Likes\"})\nfig.show()\n```\n\n```{python}\nfig = px.scatter(df, x=\"tik_tok_views\", y=\"tik_tok_likes\",\n                 marginal_y=\"violin\", marginal_x=\"violin\", \n                 trendline=\"ols\", template=\"simple_white\",\n                 title = \"TikTok Likes as a function of Views\",\n                 labels = {\"tik_tok_views\":\"TikTok Views\", \"tik_tok_likes\":\"TikTok Likes\"})\nfig.show()\n```\n\nFrom the two plots above we learn that the YouTube views only explain about 70% ($R^2$ = .6954) of the total variation in YouTube likes, whereas TikTok views are a strong correlate of TikTok likes ending up explaining 98% of their total variation.\n:::\n\n# Data Modeling\n\nWe now delve deeper into the statistical associations between the different variables in the dataset by fitting a linear model.\n\n```{r}\nyt_lm <- lm(you_tube_likes ~ you_tube_views, data = df_cleaned)\nsummary(yt_lm)\n```\n\n```{r}\npar(mfrow = c(2,2))\nplot(yt_lm)\n```\n\nThis time we learn much more from the diagnostics of the residuals of the model. Importantly, the errors do not have a mean of zero and show significant departures from the assumption of normality (as can be seen in the top-right plot). More importantly, also the assumption of equal error variance is violated. In the bottom-right plot, we also see that there are some outliers whose presence is greatly affecting the estimated regression coefficients.\n\n```{r, include=FALSE}\noutliers <- boxplot(df_cleaned$you_tube_likes, ylab = \"YT Likes\")$out\ndf_cleaned_no_out <- df_cleaned[-which(df_cleaned$you_tube_likes %in% outliers | is.na(df_cleaned$you_tube_likes)),]\n```\n\n```{r, include = FALSE}\n#outliers <- boxplot(df_cleaned$you_tube_likes, ylab = \"YT Likes\")$out\n#df_cleaned_no_out <- df_cleaned[-which(df_cleaned$you_tube_likes %in% outliers | is.na(df_cleaned$you_tube_likes)),]\nyt_lm_no_out <- lm(you_tube_likes ~ you_tube_views, data = df_cleaned_no_out)\nsummary(yt_lm)\n```\n\n# Conclusion\n\nThis document is a streamlined example of how it is possible to produce automatic reports in different formats starting from a single and connected quarto document file. The main features of this automatic report are:\n\n1.  connection and retrieval of data from parquet files or any other instances of SQL databases.\n2.  data cleaning and pre-processing.\n3.  up-to-date data visualization processes that ensure that the most relevant plots are generated from the most recent data.\n4.  up-to-date data modeling processes that automatically update their parameters based on the new data they receive.\n\n::: callout-important\nThis document should not be viewed as a final and finished product as some aspects of the data management and engineering process were not discussed (e.g., data integrity, patterns in data missingness, advanced handling of outliers, etc.)\n\nView this document as an example of the impact that an automatic report can have on the reporting process in a corporate setting.\n:::\n\n# Resources\n\nApache Software Foundation, “Tabular Datasets — Apache Arrow v19.0.0.” Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://arrow.apache.org/docs/python/dataset.html#dataset>\n\nNicholas Tierney, *Exploring patterns with UpSetR*. Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://cran.r-project.org/web/packages/naniar/vignettes/naniar-visualisation.html>\n\nNicholas Tierney, Di Cook, Miles McBain, and Colin Fay, “Plot the pattern of missingness using an upset plot. — gg_miss_upset.” Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://naniar.njtierney.com/reference/gg_miss_upset.html>\n\nNIDULA ELGIRIYEWITHANA, “Most Streamed Spotify Songs 2024.” Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://www.kaggle.com/datasets/nelgiriyewithana/most-streamed-spotify-songs-2024>\n\nRich Pauloo, “Parquet, SQL, DuckDB, arrow, dbplyr and R,” Rich Pauloo. Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://www.richpauloo.com/blog/parquet/>\n\nP. Team, “Posit,” Posit. Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://www.posit.co/>\n","srcMarkdownNoYaml":"\n\n## Info about the dataset\n\nData has been retrieved from [kaggle](https://www.kaggle.com/datasets/nelgiriyewithana/most-streamed-spotify-songs-2024/data).\n\nThe dataset description is reported below:\n\n-   **Track Name**: Name of the song.\n\n-   **Album Name**: Name of the album the song belongs to.\n\n-   **Artist**: Name of the artist(s) of the song.\n\n-   **Release Date**: Date when the song was released.\n\n-   **ISRC**: International Standard Recording Code for the song.\n\n-   **All Time Rank**: Ranking of the song based on its all-time popularity.\n\n-   **Track Score**: Score assigned to the track based on various factors.\n\n-   **Spotify Streams**: Total number of streams on Spotify.\n\n-   **Spotify Playlist Count**: Number of Spotify playlists the song is included in.\n\n-   **Spotify Playlist Reach**: Reach of the song across Spotify playlists.\n\n-   **Spotify Popularity**: Popularity score of the song on Spotify.\n\n-   **YouTube Views**: Total views of the song's official video on YouTube.\n\n-   **YouTube Likes**: Total likes on the song's official video on YouTube.\n\n-   **TikTok Posts**: Number of TikTok posts featuring the song.\n\n-   **TikTok Likes**: Total likes on TikTok posts featuring the song.\n\n-   **TikTok Views**: Total views on TikTok posts featuring the song.\n\n-   **YouTube Playlist Reach**: Reach of the song across YouTube playlists.\n\n-   **Apple Music Playlist Count**: Number of Apple Music playlists the song is included in.\n\n-   **AirPlay Spins**: Number of times the song has been played on radio stations.\n\n-   **SiriusXM Spins**: Number of times the song has been played on SiriusXM.\n\n-   **Deezer Playlist Count**: Number of Deezer playlists the song is included in.\n\n-   **Deezer Playlist Reach**: Reach of the song across Deezer playlists.\n\n-   **Amazon Playlist Count**: Number of Amazon Music playlists the song is included in.\n\n-   **Pandora Streams**: Total number of streams on Pandora.\n\n-   **Pandora Track Stations**: Number of Pandora stations featuring the song.\n\n-   **Soundcloud Streams**: Total number of streams on Soundcloud.\n\n-   **Shazam Counts**: Total number of times the song has been Shazamed.\n\n-   **TIDAL Popularity**: Popularity score of the song on TIDAL.\n\n-   **Explicit Track**: Indicates whether the song contains explicit content.\n\nThis is a test to check some of the functionality integrated to be integrated in a possible version of an automated reporting for spotify.\n\n## Creating the R and Python environments using `renv` and `venv`\n\nThe environment is created before loading any package and is stored in the file *build-env.R*.\n\n```{r, include=FALSE}\nlibrary(pacman)\np_load(tidyverse, arrow, duckdb, fs, DBI, glue, janitor, ggplot2, ggthemes, visdat, UpSetR, naniar)\n\n#options(scipen = 999)\noptions(scipen = 0)\n```\n\n## Using R to create a parquet file\n\n::: callout-note\nThis section should be executed only the first time to generate the parquet file, then we can just query that file using the opened connection to the database to extract and load only the necessary data in memory.\n:::\n\n```{r, warning=FALSE}\ndf <- read_csv(\"data/raw/2024_spotify-most-streamed.csv\")\n```\n\n```{r}\ndf_cleaned <- janitor::clean_names(df)\n```\n\n```{r}\ndir_out <- \"data/parquet/\"\n```\n\n```{r}\narrow::write_dataset(df_cleaned, dir_out, partitioning = \"spotify_popularity\")\n```\n\n### accessing and querying the parquet files using SQL and DuckDB\n\n```{r}\ndir_out <- \"data/parquet/\"\n```\n\n```{r}\nds <- open_dataset(dir_out, partitioning = \"spotify_popularity\")\n\ncon <- dbConnect(duckdb())\n\nduckdb_register_arrow(con, \"spotify_artists\", ds)\n\ndf_very_popular <- dbGetQuery(con,\n           \"SELECT *\n           FROM spotify_artists\n           WHERE spotify_popularity >= 70\")\n\ndf_not_popular <- dbGetQuery(con,\n           \"SELECT *\n           FROM spotify_artists\n           WHERE spotify_popularity < 70\")\n```\n\n```{r}\nduckdb_unregister(con, \"spotify_artists\")\ndbDisconnect(con)\n```\n\nThis ensures that after querying we disconnect and close the connection to the database.\n\n# Visualizing the data\n\nWe can first check the structure of the dataset to make sure that the type of every variable is consistent with what they are supposed to represent.\n\n```{r}\nstr(df_very_popular)\n```\n\nWe learn that the column `tidal_popularity` is full of empty values, so we should drop it from the dataset. Also, `release_date` is not properly initialized as a `date` object, so it would be useful to convert it into one.\n\n```{r}\ndf_cleaned_pop <- df_very_popular %>%\n  select(-tidal_popularity) %>%\n  mutate(release_date = mdy(release_date))\n```\n\nLet's say we want to try to understand the popularity of a track on spotify based on the number of likes it got. First let's visualize the most popular artists\n\n```{r}\nspotify_green <- \"#1DB954\"\n```\n\n```{r}\ndf_cleaned_pop %>%\n  group_by(artist) %>%\n  summarise(count = dplyr::n()) %>%\n  arrange(desc(count)) %>%\n  head(5) %>%\n  ggplot(aes(x = artist)) +\n    geom_col(aes(y = count), color = \"black\", fill = spotify_green) +\n    #stat_summary(aes(y = stat_identity(count))) +\n    labs(x = \"Artist\", y = \"Number of Popular Tracks (2024)\",\n         title = \"Top 5\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n```\n\nNow we might be interested in knowing from which year are the tracks contained in the dataset. We can observe the distribution using another barplot\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(release_year = year(release_date)) %>%\n  group_by(release_year) %>%\n  summarize(count = n()) %>%\n  ggplot(aes(x = release_year)) +\n    geom_col(aes(y = count), color = \"black\", fill = spotify_green) +\n    #stat_summary(aes(y = stat_identity(count))) +\n    labs(x = \"Year\", y = \"Number of Popular Tracks (2024)\",\n         title = \"Distribution of Release Year\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n  \n```\n\nMost of the popular songs are from 2023 and 2024, although there are a few outliers coming from the late 80s and early 90s. At this point one might be interested in understanding if the appearance of these songs on the chart is associated to the number of likes they received on social media platforms (e.g., TikTok & Instagram). Luckily, we also have this kind of data, so we can check how these two groups differ on the number of likes they received on social media.\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(period = ifelse(year(release_date) <= 2010, \"old\", \"recent\")) %>%\n  ggplot(aes(x = period, y = tik_tok_likes)) +\n  geom_boxplot(color = \"black\", fill = spotify_green) +\n  labs(x = \"Year\", y = \"Number of TikTok Likes (2024)\",\n         title = \"TikTok Likes by Period\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n```\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(period = ifelse(year(release_date) <= 2010, \"old\", \"recent\")) %>%\n  ggplot(aes(x = period, y = you_tube_likes)) +\n  geom_boxplot(color = \"black\", fill = spotify_green) +\n  labs(x = \"Year\", y = \"Number of YouTube Likes (2024)\",\n         title = \"YouTube Likes by Period\") +\n    theme_clean() +\n    theme(plot.title = element_text(hjust = .5, size = 18, color = spotify_green),\n          axis.title.x = element_text(face = \"bold\"))\n```\n\nHowever, there are many missing values for the TikTok category and so it is difficult to make a fair comparison. Also, YouTube has been around for much longer compared to TikTok so it makes sense that older songs gathered more likes throughout the years. Interestingly, among the old songs there is just one outlier in the YouTube category compared to the many in the TikTok group.\n\n```{r}\ndf_cleaned_pop %>%\n  mutate(period = ifelse(year(release_date) <= 2010, \"old\", \"recent\")) %>%\n  select(tik_tok_likes, you_tube_likes) %>%\n  vis_miss()\n```\n\n::: {.content-visible when-format=\"html\"}\n```{python}\nimport pyarrow.dataset as ds\nimport pandas as pd\nimport plotly.express as px\nimport plotly.io as pio\n\npio.renderers.default = \"plotly_mimetype+notebook_connected\"\n\ndf = ds.dataset(\"data/parquet\", format=\"parquet\").to_table().drop([\"artist\", \"album_name\", \"track\"]).to_pandas()\n\n#print(df)\n\n#df = pd.read_csv(\"~/Desktop/Projects/R_projects/test_reporting/data/raw/2024_spotify-most-streamed.csv\")\n\nfig = px.scatter(df, x=\"you_tube_views\", y=\"you_tube_likes\",\n                 marginal_y=\"violin\", marginal_x=\"violin\", \n                 trendline=\"ols\", template=\"simple_white\",\n                 title = \"YouTube Likes as a function of Views\",\n                 labels = {\"you_tube_views\":\"YT Views\", \"you_tube_likes\":\"YT Likes\"})\nfig.show()\n```\n\n```{python}\nfig = px.scatter(df, x=\"tik_tok_views\", y=\"tik_tok_likes\",\n                 marginal_y=\"violin\", marginal_x=\"violin\", \n                 trendline=\"ols\", template=\"simple_white\",\n                 title = \"TikTok Likes as a function of Views\",\n                 labels = {\"tik_tok_views\":\"TikTok Views\", \"tik_tok_likes\":\"TikTok Likes\"})\nfig.show()\n```\n\nFrom the two plots above we learn that the YouTube views only explain about 70% ($R^2$ = .6954) of the total variation in YouTube likes, whereas TikTok views are a strong correlate of TikTok likes ending up explaining 98% of their total variation.\n:::\n\n# Data Modeling\n\nWe now delve deeper into the statistical associations between the different variables in the dataset by fitting a linear model.\n\n```{r}\nyt_lm <- lm(you_tube_likes ~ you_tube_views, data = df_cleaned)\nsummary(yt_lm)\n```\n\n```{r}\npar(mfrow = c(2,2))\nplot(yt_lm)\n```\n\nThis time we learn much more from the diagnostics of the residuals of the model. Importantly, the errors do not have a mean of zero and show significant departures from the assumption of normality (as can be seen in the top-right plot). More importantly, also the assumption of equal error variance is violated. In the bottom-right plot, we also see that there are some outliers whose presence is greatly affecting the estimated regression coefficients.\n\n```{r, include=FALSE}\noutliers <- boxplot(df_cleaned$you_tube_likes, ylab = \"YT Likes\")$out\ndf_cleaned_no_out <- df_cleaned[-which(df_cleaned$you_tube_likes %in% outliers | is.na(df_cleaned$you_tube_likes)),]\n```\n\n```{r, include = FALSE}\n#outliers <- boxplot(df_cleaned$you_tube_likes, ylab = \"YT Likes\")$out\n#df_cleaned_no_out <- df_cleaned[-which(df_cleaned$you_tube_likes %in% outliers | is.na(df_cleaned$you_tube_likes)),]\nyt_lm_no_out <- lm(you_tube_likes ~ you_tube_views, data = df_cleaned_no_out)\nsummary(yt_lm)\n```\n\n# Conclusion\n\nThis document is a streamlined example of how it is possible to produce automatic reports in different formats starting from a single and connected quarto document file. The main features of this automatic report are:\n\n1.  connection and retrieval of data from parquet files or any other instances of SQL databases.\n2.  data cleaning and pre-processing.\n3.  up-to-date data visualization processes that ensure that the most relevant plots are generated from the most recent data.\n4.  up-to-date data modeling processes that automatically update their parameters based on the new data they receive.\n\n::: callout-important\nThis document should not be viewed as a final and finished product as some aspects of the data management and engineering process were not discussed (e.g., data integrity, patterns in data missingness, advanced handling of outliers, etc.)\n\nView this document as an example of the impact that an automatic report can have on the reporting process in a corporate setting.\n:::\n\n# Resources\n\nApache Software Foundation, “Tabular Datasets — Apache Arrow v19.0.0.” Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://arrow.apache.org/docs/python/dataset.html#dataset>\n\nNicholas Tierney, *Exploring patterns with UpSetR*. Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://cran.r-project.org/web/packages/naniar/vignettes/naniar-visualisation.html>\n\nNicholas Tierney, Di Cook, Miles McBain, and Colin Fay, “Plot the pattern of missingness using an upset plot. — gg_miss_upset.” Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://naniar.njtierney.com/reference/gg_miss_upset.html>\n\nNIDULA ELGIRIYEWITHANA, “Most Streamed Spotify Songs 2024.” Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://www.kaggle.com/datasets/nelgiriyewithana/most-streamed-spotify-songs-2024>\n\nRich Pauloo, “Parquet, SQL, DuckDB, arrow, dbplyr and R,” Rich Pauloo. Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://www.richpauloo.com/blog/parquet/>\n\nP. Team, “Posit,” Posit. Accessed: Feb. 01, 2025. \\[Online\\]. Available: <https://www.posit.co/>\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"2024-01-31_test-automated-reporting-spotify.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","title":"Testing Automated Reporting","editor":"visual"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":[]}